#lang rhombus
import: pict as p
        pict/radial as pr
        draw
        rhombus/rx open


fun cube(x :: Number):
  x*x*x

fun text(string :: String, font_size ::  Real.in(1, 255 ~inclusive), color :: String):
  def str = rx'"\n"'.split(string)
  def strs = for List(x : str):
    p.text(x,~font:draw.Font(~size:font_size)).colorize(color)
  p.stack(~horiz:#'left,& strs)

fun mode_to_color(mode):
  cond
  | mode == "solid": [#'inherit,1]
  | mode == "outline": [#false,1]
  | mode is_a Number: mode :: Real.in(0,255 ~inclusive)
                      [#'inherit,mode/255]
  | ~else: error(~who: #'mode_to_color,
                 "expects a mode as second argument",
                 ~details: ["given:",mode])

fun circle(radius :: NonnegReal, mode, color):
  p.circle(~size:radius * 2, ~fill: mode_to_color(mode)[0]).colorize(color).alpha(mode_to_color(mode)[1])

fun square(side_len :: NonnegReal, mode, color): 
  p.square(~size:side_len, ~fill: mode_to_color(mode)[0]).colorize(color).alpha(mode_to_color(mode)[1])

fun rotate(angle :: Number, image):
  image.rotate(angle * math.pi/180)

fun overlay(x :: p.Pict,...): 
  p.overlay(x,...)

fun beside(x,...): 
  p.beside(x,...)

fun triangle(side_len :: NonnegReal, mode, color):  
  pr.radial_pict(~points:3, ~width:side_len, ~height:side_len, ~fill:mode_to_color(mode)[0],~bound: #'shrink).colorize(color).alpha(mode_to_color(mode)[1])

fun rectangle(width :: NonnegReal, height :: NonnegReal, mode, color): 
  p.rectangle(~width:width, ~height:height, ~fill:mode_to_color(mode)[0]).colorize(color).alpha(mode_to_color(mode)[1])

fun above(x,...):
  p.stack(x,...)

fun scale_xy(x :: Number, y :: Number, image):
  image.scale(x,y)

fun place_image(image, x, y, scene):
  p.pin(~on: scene,~at: p.Find.left_top(scene,~dx:x,~dy:y),~pinhole: p.Find.center(image),image)
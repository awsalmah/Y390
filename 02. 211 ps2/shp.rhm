;; shp stands for ShortHandProgram
#lang rhombus
import: pict as p
        pict/radial as pr
        draw
        rhombus/rx open

export: text
        mode_to_color
        circle
        square
        rotate
        overlay
        beside
        triangle
        rectangle
        above
        scale_xy
        place_image
        triangle2
        
// create a star function and a rhombus function
// call mode_to_color once instead of twice
//dont want any of the pict apis a string is fine or extend to support color structs
fun text(string :: String, font_size ::  Real.in(1, 255 ~inclusive), color :: String )://colormode?
  def str = rx'"\n"'.split(string)
  def strs = for List(x : str):
    p.text(x,~font:draw.Font(~size:font_size)).colorize(color)
  p.stack(~horiz:#'left,& strs)

fun mode_to_color(mode):
  cond
  | mode == "solid": [#'inherit,1]
  | mode == "outline": [#false,1]
  | mode is_a Number: mode :: Real.in(0,255 ~inclusive)
                      [#'inherit,mode/255]
  | ~else: error(~who: #'mode_to_color,
                 "expects a mode as second argument",
                 ~details: ["given:",mode])

fun circle(radius :: NonnegReal, mode, color :: String):
  p.circle(~size:radius * 2, ~fill: mode_to_color(mode)[0]).colorize(color).alpha(mode_to_color(mode)[1])

fun square(side_len :: NonnegReal, mode, color :: String): 
  p.square(~size:side_len, ~fill: mode_to_color(mode)[0]).colorize(color).alpha(mode_to_color(mode)[1])

fun rotate(angle :: Number, image :: p.Pict):
  image.rotate(angle * math.pi/180)

fun overlay(x :: p.Pict,...): 
  p.overlay(x,...)

fun beside(x :: p.Pict,...): 
  p.beside(x,...)
// call racket functions from 2htdp img
// get test failures if anything changes like unit testing
//check width and height as they differ from racket ==> ask about this 1.16 floor and ceiling
// round up
  //check a triangle with each angle of size 60

fun triangle(side_len :: NonnegReal, mode, color:: String):
  def height = math.round(side_len * math.sqrt(3)/2)
  p.polygon([[side_len/2,0], [side_len,height], [0,height]], ~fill: mode_to_color(mode)[0]).colorize(color).alpha(mode_to_color(mode)[1])
//triangle with lines // cba
  //p.polygon([[50,0], [100, 100],[0, 100]], ~fill: "lightgreen") // cba
fun triangle2(side_len :: NonnegReal, mode, color :: String):
  def width = math.floor(side_len * 1.16)
  def height = math.floor(side_len * 1.16)
  pr.radial_pict(~points:3, ~width:side_len, ~height: side_len, ~fill:mode_to_color(mode)[0],~bound: #'shrink).colorize(color).alpha(mode_to_color(mode)[1])
//triangle with lines
fun rectangle(width :: NonnegReal, height :: NonnegReal, mode, color :: String): 
  p.rectangle(~width:width, ~height:height, ~fill:mode_to_color(mode)[0]).colorize(color).alpha(mode_to_color(mode)[1])

fun above(x :: p.Pict,...):
  p.stack(x,...)

fun scale_xy(x :: NonnegReal, y :: NonnegReal, image :: p.Pict):
  image.scale(x,y)

fun place_image(image :: p.Pict, x :: Real, y :: Real, scene :: p.Pict):
  p.pin(~on: scene,~at: p.Find.left_top(scene,~dx:x,~dy:y),~pinhole: p.Find.center(image),image).clip()

fun scene_line(image :: p.Pict, x1 :: Real, y1 :: Real, x2 :: Real, y2 :: Real, clr):
  // check overlay first then this place_image(image,)
  // overlay does not work because the location of the line is always in the center
  def ln = line(x2-x1,y2-y1,clr)
  //place_image(line(x2-x1,y2-y1,clr),x1,y1,image)
  p.pin(~on: image,~at: p.Find.left_top(image,~dx:x1,~dy:y1),~pinhole: p.Find.left_top(ln),ln).clip()
  // place_image(line((x2-x1) * 2,(y2-y1 )* 2,clr),x1,y1,image)
// p.pin(~on: image,~at: p.Find(image,~dx:x1,~dy:y1),~pinhole: p.Find(l1),l2) // doesnt work in most cases
  // overlay(rectangle(math.abs(x2-x1),math.abs(y2-y1),0,"white"),image,line(x2-x1,y2-y1,clr))
  // overlay(square(60,0,"blue"),square(40,255,"gray"),line(60,-60,"red")) => check width and height
// add pen support in the future switch clr with penorclr
fun line(x1, y1, penorclr):
  // Constructs an image representing a line segment that connects the points (0,0) to (x1,y1).
  // Creates a pict that draws a line from the top-left of the pict.
  // The dx and dy arguments determine both the shape of the line and the width and height of the pict.
  p.line(~dx: x1, ~dy: y1, ~line: penorclr)
//// p.line(~dx: math.round(1+ x1), ~dy: math.round(1+ y1), ~line: penorclr)
  // implement smthn similar to be like racket / check racket text file
  // check the difference in width
p.line(~dx: 10, ~dy: 10)
p.line(~dx:10,~dy:-10,~line:"blue",~line_width: 3)
rectangle(40,40,255,"gray")
place_image(p.line(~dx: 40, ~dy: 40),0,0,rectangle(40,40,255,"gray"))
place_image(p.line(~dx: 75, ~dy: 75),0,0,rectangle(40,40,255,"gray"))
p.line(~dx:100,~dy:100,~line:"blue",~line_width: 3) //left to right and downwards
p.line(~dx:100,~dy:-100,~line:"blue",~line_width: 3) // left to right and upwards
p.line(~dx:-100,~dy:100,~line:"blue",~line_width: 3) // right to left and downwards
p.line(~dx:-100,~dy:-100,~line:"blue",~line_width: 3) // right to left and upwards
line(30,30,"black")
line(-30,20,"red")
line(30,-20,"red").width
line(30,-20,"red").height
scene_line(square(40,255,"gray"),-10,50,50,-10,"maroon")
scene_line(circle(20,"outline","maroon"),0,40,40,0,"maroon") // create ellipse function
scene_line(rectangle(100,100,255,"darkolivegreen"),25,25,100,100,"maroon")
